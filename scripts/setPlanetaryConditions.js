#!/usr/bin/env node

// Authoring script: Set initial planetary conditions for a problem taxonomy point.
// Usage:
//   node scripts/setPlanetaryConditions.js MONEY_BUSINESS_GENERAL

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { getPointById, THEMES } from '../src/config/problemTaxonomy.js';
import { query } from '../config/db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function printHeader(title) {
  console.log('='.repeat(60));
  console.log(title);
  console.log('='.repeat(60));
}

async function saveConditionsJson(point, mock) {
  const rulesDir = path.resolve(
    __dirname,
    '../astro-authoring/rules',
    point.theme,
    point.subtype
  );
  await fs.promises.mkdir(rulesDir, { recursive: true });

  const filePath = path.join(rulesDir, `${point.id}.json`);

  const payload = {
    pointId: point.id,
    theme: point.theme,
    subtype: point.subtype,
    polarity: point.polarity,
    kind: point.kind,
    defaultScopes: point.defaultScopes,
    condition_tree: mock.condition_tree,
    effect_json: mock.effect_json,
  };

  await fs.promises.writeFile(filePath, JSON.stringify(payload, null, 2), 'utf8');
  console.log(`\nüíæ Saved draft conditions to ${filePath}`);
}

// Map taxonomy theme ‚Üí effect_json.theme
function mapEffectTheme(theme) {
  switch (theme) {
    case THEMES.MONEY_FINANCE:
      return 'money';
    case THEMES.CAREER_DIRECTION:
      return 'career';
    case THEMES.RELATIONSHIPS:
      return 'relationship';
    case THEMES.FAMILY_HOME:
      return 'family';
    case THEMES.HEALTH_BODY:
      return 'health';
    case THEMES.MENTAL_STATE:
      return 'mental_state';
    case THEMES.SPIRITUAL_GROWTH:
      return 'spiritual';
    case THEMES.TIMING_LUCK:
      return 'timing';
    case THEMES.EVENTS_CHANGES:
      return 'events';
    case THEMES.SELF_IDENTITY:
      return 'self';
    default:
      return 'general';
  }
}

/**
 * Generate planetary conditions + effect for a point.
 *
 * JSON schema (for AI integration later):
 * {
 *   "condition_tree": {
 *     "all": [
 *       { "planet_in_house": { "planet_in": ["JUPITER"], "house_in": [2,11] } },
 *       { "planet_strength": { "planet": "JUPITER", "min_score": 0.6 } }
 *     ]
 *   },
 *   "effect_json": {
 *     "theme": "money",
 *     "area": "business",
 *     "trend": "up",
 *     "intensity": 0.7,
 *     "tone": "positive",
 *     "polarity": "positive",
 *     "kind": "achievement"
 *   }
 * }
 */
function generateConditionsForPoint(point) {
  const effectTheme = mapEffectTheme(point.theme);
  const astro = point.astroHints || {};

  const trend =
    point.polarity === 'positive'
      ? 'up'
      : point.polarity === 'negative'
      ? 'down'
      : 'mixed';

  const tone = point.polarity === 'negative' ? 'cautious' : 'positive';

  const allConditions = [];

  if (astro.houses && astro.houses.length && astro.keyPlanets && astro.keyPlanets.length) {
    allConditions.push({
      planet_in_house: {
        planet_in: astro.keyPlanets,
        house_in: astro.houses,
      },
    });
  }

  // Fallback generic condition if no astroHints present
  if (allConditions.length === 0) {
    allConditions.push({
      generic_condition: {
        note: 'No astroHints specified; generic draft condition.',
      },
    });
  }

  const condition_tree = { all: allConditions };

  const effect_json = {
    theme: effectTheme,
    area: point.subtype,
    trend,
    intensity: 0.7,
    tone,
  };

  // Basic validation
  if (!condition_tree || !effect_json) {
    throw new Error('Invalid mock: condition_tree/effect_json missing');
  }

  return { condition_tree, effect_json };
}

async function upsertRuleGroup(point) {
  const code = point.id;
  const name = `${point.label} [${point.id}]`;
  const description = point.description;

  const sql = `
    INSERT INTO rule_groups (code, name, category, description, is_active)
    VALUES ($1, $2, 'prediction', $3, TRUE)
    ON CONFLICT (code) DO UPDATE
      SET name = EXCLUDED.name,
          description = EXCLUDED.description
    RETURNING *;
  `;

  const res = await query(sql, [code, name, description]);
  return res.rows[0];
}

async function upsertRuleForPoint(point, ruleGroup, mock) {
  const ruleName = `${point.id} - Base Planetary Conditions`;
  const ruleDescription = `Draft planetary condition rule for point ${point.id} (auto-generated by setPlanetaryConditions).`;

  const priority =
    point.kind === 'problem'
      ? 80
      : point.kind === 'achievement'
      ? 70
      : point.kind === 'event'
      ? 60
      : 50;

  // Check if a rule already exists for this point + group
  const existingRes = await query(
    'SELECT id FROM rules WHERE point_code = $1 AND rule_group_id = $2 LIMIT 1',
    [point.id, ruleGroup.id]
  );

  const paramsBase = [
    ruleGroup.id,
    ruleName,
    ruleDescription,
    priority, // priority derived from point.kind
    point.defaultScopes,
    0, // min_score
    1, // max_score
    'AND',
    JSON.stringify(mock.condition_tree),
    JSON.stringify(mock.effect_json),
    1.0, // base_weight
    null, // template_id
    false, // is_active (draft)
    point.id, // point_code
  ];

  if (existingRes.rows.length > 0) {
    const ruleId = existingRes.rows[0].id;
    const sql = `
      UPDATE rules
      SET name = $2,
          description = $3,
          priority = $4,
          applicable_scopes = $5,
          min_score = $6,
          max_score = $7,
          condition_logic = $8,
          condition_tree = $9::jsonb,
          effect_json = $10::jsonb,
          base_weight = $11,
          template_id = $12,
          is_active = $13,
          point_code = $14
      WHERE id = $1
      RETURNING *;
    `;

    const res = await query(sql, [ruleId, ...paramsBase.slice(1)]);
    return { rule: res.rows[0], action: 'updated' };
  }

  const insertSql = `
    INSERT INTO rules (
      rule_group_id,
      name,
      description,
      priority,
      applicable_scopes,
      min_score,
      max_score,
      condition_logic,
      condition_tree,
      effect_json,
      base_weight,
      template_id,
      is_active,
      point_code
    )
    VALUES (
      $1, $2, $3, $4, $5, $6, $7,
      $8, $9::jsonb, $10::jsonb,
      $11, $12, $13, $14
    )
    RETURNING *;
  `;

  const res = await query(insertSql, paramsBase);
  return { rule: res.rows[0], action: 'inserted' };
}

async function main() {
  const pointId = process.argv[2];

  printHeader('üîß setPlanetaryConditions');

  if (!pointId) {
    console.error('‚ùå pointId missing.');
    console.error('   Usage: node scripts/setPlanetaryConditions.js MONEY_BUSINESS_GENERAL');
    process.exit(1);
  }

  console.log(`‚û°Ô∏è  Point ID: ${pointId}\n`);

  const point = getPointById(pointId);
  if (!point) {
    console.error(`‚ùå Point not found in taxonomy: ${pointId}`);
    process.exit(1);
  }

  console.log('üß© Point metadata:');
  console.log(JSON.stringify(point, null, 2));

  try {
    // 1. Generate mock condition + effect JSON
    const mock = generateConditionsForPoint(point);
    console.log('\nüìù Mock condition_tree + effect_json (preview):');
    console.log(JSON.stringify(mock, null, 2));

    // 2. Save to authoring JSON file (for AI / manual editing)
    await saveConditionsJson(point, mock);

    // 3. Upsert rule_group
    const group = await upsertRuleGroup(point);
    console.log('\nüìÅ Rule group upserted:');
    console.log(`   id=${group.id}, code=${group.code}, name=${group.name}`);

    // 4. Upsert rule
    const { rule, action } = await upsertRuleForPoint(point, group, mock);
    console.log('\nüìè Rule ' + action + ':');
    console.log(`   id=${rule.id}, point_code=${rule.point_code}, group_id=${rule.rule_group_id}`);
    console.log(`   applicable_scopes={${rule.applicable_scopes.join(', ')}}`);
    console.log(`   is_active=${rule.is_active}`);

    console.log('\n‚úÖ setPlanetaryConditions completed successfully.');
    process.exit(0);
  } catch (error) {
    console.error('\n‚ùå Error in setPlanetaryConditions:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  // eslint-disable-next-line no-console
  main();
}


